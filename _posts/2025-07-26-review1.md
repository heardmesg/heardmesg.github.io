---
title: "일간 ps 리뷰"
date: 2025-07-26 21:00:00
categories:
- BOJ
tags:
- BOJ
---


# [17265] - 나의 인생에는 수학과 함께
[문제 링크입니다.](https://www.acmicpc.net/problem/17265)

```cpp
char road[5][5];         // 격자 맵 (숫자 or 연산자)
ll dx[]={1,0}, dy[]={0,1}; // 방향: 아래, 오른쪽
vc expr;                 // 현재까지의 수식 (숫자, 연산자, 숫자, ...)
ll n, mx=-INT_MAX, mn=INT_MAX;  // 정답 (최댓값/최솟값)
```

전역변수입니다. 한번씩 보고가면 됩니다. "vc"는 `vector<char>`를 뜻합니다.

먼저 계산함수를 만들어주고, 현재까지의 저장된 모든 수식 문자열을 순회하면서 계산을 합니다. 항상 숫자 -> 연산자 -> 숫자 -> .. 으로 가정되어있다고 믿으시면 됩니다.

이제 dfs로 road를 순회하면서 최댓값, 최솟값을 갱신해줍니다.

# [4530] - 1은 흥미로운 숫자
[문제 링크입니다.](https://www.acmicpc.net/problem/4530)

소수는 에라토스테네스의 체로 구해주고, 제곱, 세제곱, 네제곱은 각각 sqrt,cbrt,pow를 써서 구해주면 됩니다. 이를 계속 반복하면 됩니다. 아래는 핵심 코드입니다.

```cpp
ll max_a = 0;
for (auto a : x) max_a = max(max_a, a);

vi era(max_a+1, 1);
era[0] = era[1] = 0;
for (ll i = 2; i*i <= max_a; i++) {
    if (era[i]) {
        for (ll j = i*i; j <= max_a; j += i)
            era[j] = 0;
    }
}

rep(i,n,1) {
    ll a=x[i],cnt=0;
    cnt+=is_prime(era,a);
    cnt+=is_jaegop(a);
    cnt+=is_cube(a);
    cnt+=is_quad(a);
    cnt+=is_multi(a);
    cnt+=is_pro(a);
    cnt+=is_divi(a,x);
    cnt+=is_mul(a,x);
    cnt+=is_multis(a,x);
    cnt+=is_cubes(a,x);
    cnt+=is_quads(a,x);
    cnt+=is_sums(a,x);
    cnt+=is_pros(a,x);
    yourmom.pb(make_pair(cnt,a));
}
```

설명이 부실하다면 죄송합니다. 진짜로 적을게 없어요...

# [33720] - Peeling Primes
[문제링크입니다.](https://www.acmicpc.net/problem/33720)

$N$이 소수라면 $N$을 빼주면 끝입니다.

$N$이 짝수라면 계속 2를 빼게 됩니다.

$N$이 짝수도 아니고, 소수도 아니라면 가장 작은 소인수를 구해 빼줍니다.

# [1456] - 거의 소수
[문제링크입니다.](https://www.acmicpc.net/problem/1456)

일단 2의 제곱 이상인 소수의 거듭제곱을 모두 구해줘야합니다. 이때 수의 범위가 $10^{14}$이기에, 에라토스테네스 범위는 10의 7제곱 정도면 충분합니다.

각 소수 $p$에대해 $p^2, p^3, \dots$를 적절히 곱해주면서 $B$ 이하까지 곱한 결과가 $A$ 이상일 경우에만 개수에 포함 시켜주면 됩니다. 범위가 $A=1, B=1000$이라면 거의 소수는 2의 제곱, 2의 세제곱... 총 25개 입니다. 

소수 구하기는 $O(N log log N)$, 소수마다 제곱을 반복하는 연산은 $log(b)$번만에 처리가능합니다.;

# [1777] - 순열복원
[문제링크입니다.](https://www.acmicpc.net/problem/1777)

길이 $N$인 수열 $P$에 대해, Inversion Sequence $I$가 주어집니다.

$I_i = x$라면 $i$라는 정수가 자기보다 작은 수들 $x$개 뒤에 있다는 뜻이니까 $i$를 뒤에서부터 $x$번째 앞 위치에 넣으면 조건을 만족합니다.

rope를 사용하여 삽입, 삭제를 $O(log N)$쯤에 계산해주면 됩니다.